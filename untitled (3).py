# -*- coding: utf-8 -*-
"""Untitled

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Jt1-aYK3Cq5XIKv-L5I0m8Jfp_2DXCcL
"""



import streamlit as st
import pandas as pd
import plotly.express as pt
import requests
import time

# Streamlit config
st.set_page_config(page_title="Foot Pressure Grading + Live ESP32", layout="wide")
st.title("ğŸ¦¶ Diabetic Foot Pressure Grading & Real-Time ESP32 Monitoring")

# Grading function
def grade_pressure(value):
    if value < 30:
        return "Grade 1 (Low)"
    elif value < 70:
        return "Grade 2 (Moderate)"
    else:
        return "Grade 3 (High)"

# Dataset processing
def process_dataset(df):
    for sensor in ["Sensor1", "Sensor2", "Sensor3"]:
        df[f"{sensor}_Grade"] = df[sensor].apply(grade_pressure)
    df["Mean_Pressure"] = df[["Sensor1", "Sensor2", "Sensor3"]].mean(axis=1)
    df["Overall_Grade"] = df["Mean_Pressure"].apply(grade_pressure)
    return df

# Risk evaluation
def check_risk(row):
    high_grades = sum(row[f"{s}_Grade"] == "Grade 3 (High)" for s in ["Sensor1", "Sensor2", "Sensor3"])
    return row["Mean_Pressure"] >= 70 or high_grades >= 2

# Plot trend
def plot_trend(df, title="ğŸ“ˆ Pressure Trend"):
    fig = px.line(df, x="Sample", y=["Sensor1", "Sensor2", "Sensor3"],
                  labels={"value": "Pressure", "variable": "Sensor"},
                  title=title)
    st.plotly_chart(fig, use_container_width=True)

# Sidebar for ESP32 setup
st.sidebar.header("ğŸ”Œ Live ESP32 Feed")
esp32_ip = st.sidebar.text_input("ESP32 IP Address", "192.168.27.155")
refresh_rate = st.sidebar.slider("Refresh Interval (seconds)", 2, 10, 3)
endpoint = f"http://{esp32_ip}/data"

# Button to fetch data manually
fetch_now = st.sidebar.button("ğŸ“¡ Fetch Data Now")
auto_refresh = st.sidebar.checkbox("ğŸ”„ Auto-refresh")

# Store previous samples
if "samples" not in st.session_state:
    st.session_state.samples = pd.DataFrame()

def fetch_and_display():
    try:
        response = requests.get(endpoint, timeout=2)
        if response.status_code == 200:
            data = response.json()
            df = pd.DataFrame([data])
            df["Sample"] = len(st.session_state.samples) + 1
            df = process_dataset(df)
            st.session_state.samples = pd.concat([st.session_state.samples, df], ignore_index=True)

            st.success(f"âœ… Data received from ESP32: {data}")
            st.dataframe(df, use_container_width=True)

            # Risk alert
            risky = df[df.apply(check_risk, axis=1)]
            if not risky.empty:
                st.error("âš ï¸ High Risk Detected!")
                st.dataframe(risky)
            else:
                st.success("ğŸŸ¢ No immediate risk detected.")
        else:
            st.error(f"âŒ Failed to fetch data. Status: {response.status_code}")
    except Exception as e:
        st.error(f"ğŸš« Error connecting to ESP32: {e}")

# Manual fetch
if fetch_now:
    fetch_and_display()

# Auto-refresh
if auto_refresh:
    placeholder = st.empty()
    while True:
        with placeholder.container():
            fetch_and_display()
            if not st.session_state.samples.empty:
                plot_trend(st.session_state.samples, title="ğŸ“ˆ Live Pressure Trend (ESP32)")
        time.sleep(refresh_rate)

# Show live trend if samples exist
if not st.session_state.samples.empty and not auto_refresh:
    st.subheader("ğŸ“Š Live Trend from ESP32")
    plot_trend(st.session_state.samples)